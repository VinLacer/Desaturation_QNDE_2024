# -*- coding: utf-8 -*-
"""template waveform_real.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J5FVhcVH9P2ybzuOVL7O19UVl88UNULJ

Before running, please upload [template_waveform.npz](https://drive.google.com/open?id=15K2BUfgGA2t6wP0msf4lnjk3hrtiKdov&usp=drive_fs) to the file envorinment.
"""

import numpy as np
from numpy.linalg import norm
import matplotlib.pyplot as plt
from scipy.signal import gausspulse, hilbert
from scipy.fft import fft, fftshift, fftfreq, ifft
from scipy.linalg import dft

def saturate(signal, max, min=None):
  if min is None:
    min = - max
  saturated = np.copy(signal)
  saturated[signal>max] = max
  saturated[signal<min] = min
  valid = np.ones_like(signal)
  valid[signal>=max] = 0
  valid[signal<=min] = 0
  return saturated, valid

def desaturate_dsls(g, decimator, wmin, wmax):
# Decimated Subspace Least Squares (DSLS) (proposed method)
  D = np.diag(decimator)
  D = D[decimator>0, :]
  H = dft(len(g))
  Omega = fftfreq(len(g))
  HB = H[:, (wmin <= np.abs(Omega))*(np.abs(Omega) <= wmax)]
  b = D@g
  A = D@HB
  x = np.linalg.lstsq(A, b)
  d = HB @ x[0]
  d = np.real(d)
  return [d, 0]

def desaturate_pgi(g, decimator, wmin, wmax, niter=10000):
# Papoulis Gerchberg Iteration (PGI) (competing method)
  g0 = np.copy(g)
  Omega = fftfreq(len(g))
  def ideal_band_pass(g,  wmin, wmax):
    G = fft(g)
    G[np.abs(Omega) <= wmin] = 0.
    G[np.abs(Omega) >= wmax] = 0.
    g_ = np.real(ifft(G))
    return g_
  decimator = np.array(decimator, dtype=bool)
  deltas = np.zeros(niter)
  g_bp = ideal_band_pass(g, wmin, wmax)
  g_sub = g_bp
  g_sub[decimator] = g[decimator]
  g = g_sub
  for i in np.arange(1, niter):
    g_bp = ideal_band_pass(g, wmin, wmax)
    g_sub = g_bp
    g_sub[decimator] = g[decimator]
    deltas[i] = np.sum(g_sub*g0)/(norm(g_sub)*norm(g0))
    g = g_sub
  g_bp = ideal_band_pass(g, wmin, wmax)
  return [g_bp, deltas]



figsize=(6/1.2,3/1.2)

f_s = 125e6


######### PARAMETERS #########
wmin = .0135 # [rad/sample]
#wmin = .005 # [rad/sample]
wmax = .0675 # [rad/sample]
#wmax = .08 # [rad/sample]
gate_init, gate_end = 298, 558 # sample
f_s = 125e6 # [Hz]
##############################


npz_data = np.load('template_waveform.npz', allow_pickle=True)
data = npz_data['ascans']
gains = npz_data['gains']
pulse = np.array(data[0, gate_init:gate_end], dtype=float)
pulse = pulse/np.max(np.abs(pulse))
t = np.arange(len(pulse)) / f_s

fs_dsls = [None] * len(gains)
fs_pgi = [None] * len(gains)
gs = [None] * len(gains)
decimators = [None] * len(gains)
factors = [None] * len(gains)
corrs_dsls = [None] * len(gains)
corrs_pgi = [None] * len(gains)
corrs_sat = [None] * len(gains)
deltas = [None] * len(gains)
for i in range(len(gains)):
  g = data[i, gate_init:gate_end]
  g, decimator = saturate(g, 32767/4)
  g = np.array(g, dtype=float)
  result = desaturate_dsls(g, decimator, wmin=wmin, wmax=wmax)
  f_dsls = result[0]
  corr_dsls = np.sum(f_dsls*pulse) / (norm(f_dsls)*norm(pulse))
  result = desaturate_pgi(g, decimator, wmin=wmin, wmax=wmax)
  f_pgi = result[0]
  corr_pgi = np.sum(f_pgi*pulse) / (norm(f_pgi)*norm(pulse))
  corr_sat = np.sum(g*pulse) / (norm(g)*norm(pulse))
  factor = pulse.max() / f_dsls.max()
  # Store individual values on lists
  decimators[i] = decimator
  gs[i] = g
  fs_dsls[i] = f_dsls
  fs_pgi[i] = f_pgi
  factors[i] = np.copy(factor)
  corrs_dsls[i] = corr_dsls
  corrs_pgi[i] = corr_pgi
  corrs_sat[i] = corr_sat

plt.figure(figsize=figsize)
plt.plot(gains[2:], corrs_dsls[2:], '-o')
plt.plot(gains[2:], corrs_pgi[2:], '-x')
plt.plot(gains[2:], corrs_sat[2:], '-s')
plt.xticks(np.linspace(gains[2], gains[-1], 10))
plt.xlabel('Gain [dB]')
plt.ylabel('Similarity')
plt.legend(['DSLS', 'DPG', 'Saturated'])
plt.grid()
plt.tight_layout()
plt.savefig('similarities.eps')

G = fftshift(fft(pulse))
Omega = fftshift(fftfreq(len(pulse)))
plt.figure(figsize=figsize)
fshow = 20
plt.semilogy(f_s*1e-6*Omega, np.abs(G), '.-', linewidth=.5, color='gray')
mask = (wmin<=Omega) * (Omega<=wmax)
plt.semilogy(f_s*1e-6*Omega[mask], np.abs(G[mask]), '-ok')
plt.axis([0, fshow, plt.axis()[2], plt.axis()[3]])
plt.xticks(np.linspace(0, int(fshow), 5))
plt.xlabel('Frequency [MHz]')
plt.ylabel('DFT Magnitude')
plt.grid()
plt.legend(['Discarded', 'Used'])
plt.tight_layout()
plt.savefig('spectra_real.eps')

ind = [3, 10, -1]
print(gains[ind])
for i in ind:
  plt.figure(figsize=figsize)
  plt.plot(t*1e6, pulse, 'o', alpha=.5)
  plt.plot(t*1e6, gs[i]*factors[i], '.r', linewidth=2)
  plt.plot(t*1e6, fs_pgi[i]*factors[i], 'k', linewidth=1)
  plt.legend(['0dB Template', f'Saturated ({int(gains[i])} dB)', 'Recovered'], framealpha=0)
  plt.xlabel('time [µs]')
  plt.ylabel('Rescaled amplitude')
  plt.tight_layout()
  plt.savefig(f'real_{int(gains[i])}dB.eps')

t_s = 1/f_s
plt.figure(figsize=figsize)
plt.plot(t*1e6, gs[0], ':o')
plt.plot(t*1e6, gs[-1]*.019, ':.')
yticks = np.arange(-24, 68, 4)
plt.yticks(yticks)
ytext = [None] * len(yticks)
ytext[0] = str(int(-24/4))
ytext[6] = '0'
ytext[-1] = str(int(64/4))
plt.gca().set_yticklabels(ytext)
height = 100
plt.axis([t_s*200e6, t_s*260e6, -25, 65])
plt.xlabel('time [µs]')
plt.legend([str(int(gains[0]))+' dB', str(int(gains[-1]))+' dB'])
plt.grid()
plt.savefig('quantization.eps')

plt.plot(gs[2])
gains[ind]